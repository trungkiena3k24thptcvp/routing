####################################################
# LSrouter.py
# Name:
# HUID:
#####################################################

from router import Router
from packet import Packet
import heapq
import json

class LSrouter(Router):
    """Link state routing protocol implementation.

    Add your own class fields and initialization code (e.g. to create forwarding table
    data structures). See the `Router` base class for docstrings of the methods to
    override.
    """

    def __init__(self, addr, heartbeat_time):
        Router.__init__(self, addr)  # Initialize base class - DO NOT REMOVE
        self.heartbeat_time = heartbeat_time
        self.last_time = 0
        # TODO
        #   add your own class fields and initialization code here
        self.seq_num = 0
        self.topology = {self.addr: {'links': {}, 'seq_num': 0}}
        self.forwarding_table = {}
        self.links_data = {}
    def dijkstra(self):
        f = {}
        for addr in self.topology: f[addr] = 360000
        f[self.addr] = 0
        cli_to_router = {}
        cli_list = set()
        for a in self.topology:
            for po, (neighbor, cost) in self.topology[a]['links'].items():
                if(neighbor >= 'a' and neighbor <= 'z' and neighbor not in cli_list):
                    cli_list.add(neighbor)
                    cli_to_router[neighbor] = a
        pre = {}
        port = {}
        visited = set()
        for addr in self.topology: pre[addr] = addr

        for p in self.links_data:
            endpoint = self.links_data[p][0]
            port[endpoint] = p

        pq = [(0, self.addr)]
        while pq:
            dist, u = heapq.heappop(pq)
            if u in visited:
                continue
            visited.add(u)
            for po, (neighbor, cost) in self.topology[u]['links'].items():
                if neighbor in f and dist + cost < f[neighbor]:
                    f[neighbor] = dist + cost
                    pre[neighbor] = u
                    heapq.heappush(pq, (f[neighbor], neighbor))

        new_fw_table = {}

        for addr in self.topology:
            if f[addr] == 360000:
                continue
            if addr == self.addr:
                new_fw_table[addr] = -1
                continue
            x = addr
            while(pre[x] != self.addr):
                x = pre[x]
            new_fw_table[addr] = port[x]

        for x in cli_list:
            if f[cli_to_router[x]] == 360000:
                continue
            new_fw_table[x] = new_fw_table[cli_to_router[x]]

        addr = self.addr
        for po, (neighbor, cost) in self.topology[addr]['links'].items():
            if (neighbor >= 'a' and neighbor <= 'z'):
                new_fw_table[neighbor] = po

        self.forwarding_table = new_fw_table
        return



    def handle_packet(self, port, packet):
        """Process incoming packet."""
        # TODO
        if packet.is_traceroute:
            # Hint: this is a normal data packet
            # If the forwarding table contains packet.dst_addr
            #   send packet based on forwarding table, e.g., self.send(port, packet)
            if packet.dst_addr in self.forwarding_table and packet.dst_addr is not self.addr:
                self.send(self.forwarding_table[packet.dst_addr], packet)
        else:
            # Hint: this is a routing packet generated by your routing protocol
            # If the sequence number is higher and the received link state is different
            #   update the local copy of the link state
            #   update the forwarding table
            #   broadcast the packet to other neighbors
            content = json.loads(packet.content)
            seq_num = content['seq_num']
            links = {port: tuple(link) for port, link in content['links'].items()}

            if packet.src_addr not in self.topology or seq_num > self.topology[packet.src_addr]['seq_num']:
                self.topology[packet.src_addr] = {'links': links, 'seq_num': seq_num}
                self.dijkstra()
                for p in self.links_data:
                    if p != port:
                        self.send(p, packet)

    def handle_new_link(self, port, endpoint, cost):
        """Handle new link."""
        # TODO
        #   update local data struc
        # tures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        self.links_data[port] = (endpoint, cost)
        self.seq_num += 1
        self.topology[self.addr] = {
            'links': {p: (ep, c) for p, (ep, c) in self.links_data.items()},
            'seq_num': self.seq_num
        }
        self.dijkstra()
        content = json.dumps({'links': self.topology[self.addr]['links'], 'seq_num': self.seq_num})
        packet = Packet(kind=Packet.ROUTING, src_addr=self.addr, dst_addr=None, content=content)

        for p in self.links_data:
            self.send(p, packet)
        return

    def handle_remove_link(self, port):
        """Handle removed link."""
        # TODO
        #   update local data structures and forwarding table
        #   broadcast the new link state of this router to all neighbors
        if port in self.links_data:
            old = self.links_data.copy()
            del self.links_data[port]
            self.seq_num += 1
            self.topology[self.addr] = {
                'links': {p: (ep, c) for p, (ep, c) in self.links_data.items()},
                'seq_num': self.seq_num
            }
            self.dijkstra()
            content = json.dumps({'links': self.topology[self.addr]['links'], 'seq_num': self.seq_num})
            packet = Packet(kind=Packet.ROUTING, src_addr=self.addr, dst_addr=None, content=content)

            for p in old:
                self.send(p, packet)
            return

    def handle_time(self, time_ms):
        """Handle current time."""
        if time_ms - self.last_time >= self.heartbeat_time:
            self.last_time = time_ms
            # TODO
            #  broadcast the link state of this router to all neighbors
            self.seq_num += 1

            self.topology[self.addr] = {
                'links': {p: (ep, c) for p, (ep, c) in self.links_data.items()},
                'seq_num': self.seq_num
            }

            content = json.dumps({'links': self.topology[self.addr]['links'], 'seq_num': self.seq_num})
            packet = Packet(kind=Packet.ROUTING, src_addr=self.addr, dst_addr=None, content=content)
            for p in self.links_data:
                self.send(p, packet)

    def __repr__(self):
        """Representation for debugging in the network visualizer."""
        # TODO
        #   NOTE This method is for your own convenience and will not be graded
        return f"LSrouter(addr={self.addr})"
